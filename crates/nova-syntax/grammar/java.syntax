# Java syntax tree grammar for `nova-syntax`.
#
# This file is the single source of truth for the generated typed AST wrappers in
# `crates/nova-syntax/src/ast/generated.rs`.
#
# Regenerate the wrappers with:
#   cargo xtask codegen
#
# Syntax (very small DSL):
# - `Foo { ... }` defines a concrete syntax node (must correspond to `SyntaxKind::Foo`).
# - `Bar = A | B | C` defines a typed union over existing nodes.
# - Fields:
#     field: Type     (exactly one, accessor returns `Option<Type>`)
#     field: Type?    (zero or one, accessor returns `Option<Type>`)
#     field: Type*    (zero or more, accessor returns an iterator)
# - `Ident` is a special token class which matches `SyntaxKind::is_identifier_like()`.
# - `Token(Kind)` is a token accessor for a concrete `SyntaxKind` variant.

TypeDeclaration =
    ClassDeclaration
  | InterfaceDeclaration
  | EnumDeclaration
  | RecordDeclaration
  | AnnotationTypeDeclaration
  | EmptyDeclaration

ClassMember =
    FieldDeclaration
  | MethodDeclaration
  | ConstructorDeclaration
  | InitializerBlock
  | EmptyDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | EnumDeclaration
  | RecordDeclaration
  | AnnotationTypeDeclaration

Statement =
     Block
  | LabeledStatement
  | IfStatement
  | SwitchStatement
  | ForStatement
  | WhileStatement
  | DoWhileStatement
  | SynchronizedStatement
  | TryStatement
  | AssertStatement
  | YieldStatement
  | ReturnStatement
  | ThrowStatement
  | BreakStatement
  | ContinueStatement
  | LocalTypeDeclarationStatement
  | LocalVariableDeclarationStatement
  | ExpressionStatement
  | EmptyStatement

Expression =
       LiteralExpression
    | NameExpression
    | ThisExpression
    | SuperExpression
    | ParenthesizedExpression
    | NewExpression
    | ArrayCreationExpression
    | MethodCallExpression
    | FieldAccessExpression
    | ArrayAccessExpression
    | ClassLiteralExpression
    | MethodReferenceExpression
    | ConstructorReferenceExpression
    | UnaryExpression
    | BinaryExpression
    | InstanceofExpression
    | AssignmentExpression
    | ConditionalExpression
    | SwitchExpression
    | LambdaExpression
    | CastExpression
    | ArrayInitializer

LambdaBody = Block | Expression

SwitchRuleBody = Block | Statement | Expression

ModuleDirectiveKind =
    RequiresDirective
  | ExportsDirective
  | OpensDirective
  | UsesDirective
  | ProvidesDirective

CompilationUnit {
  package: PackageDeclaration?
  imports: ImportDeclaration*
  module_declaration: ModuleDeclaration?
  type_declarations: TypeDeclaration*
}

PackageDeclaration {
  annotations: Annotation*
  name: Name?
}

ImportDeclaration {
  name: Name?
}

Modifiers {
  annotations: Annotation*
}

Annotation {
  name: Name?
  arguments: AnnotationElementValuePairList?
}

AnnotationElementValuePairList {
  pairs: AnnotationElementValuePair*
  value: AnnotationElementValue?
}

AnnotationElementValuePair {
  name_token: Ident?
  value: AnnotationElementValue?
}

AnnotationElementValue {
  expression: Expression?
  annotation: Annotation?
  array_initializer: AnnotationElementValueArrayInitializer?
}

AnnotationElementValueArrayInitializer {
  values: AnnotationElementValue*
}

Name {}

ClassDeclaration {
  modifiers: Modifiers?
  name_token: Ident?
  type_parameters: TypeParameters?
  extends_clause: ExtendsClause?
  implements_clause: ImplementsClause?
  permits_clause: PermitsClause?
  body: ClassBody?
}

InterfaceDeclaration {
  modifiers: Modifiers?
  name_token: Ident?
  type_parameters: TypeParameters?
  extends_clause: ExtendsClause?
  implements_clause: ImplementsClause?
  permits_clause: PermitsClause?
  body: InterfaceBody?
}

EnumDeclaration {
  modifiers: Modifiers?
  name_token: Ident?
  implements_clause: ImplementsClause?
  permits_clause: PermitsClause?
  body: EnumBody?
}

RecordDeclaration {
  modifiers: Modifiers?
  name_token: Ident?
  type_parameters: TypeParameters?
  parameter_list: ParameterList?
  implements_clause: ImplementsClause?
  permits_clause: PermitsClause?
  body: RecordBody?
}

AnnotationTypeDeclaration {
  modifiers: Modifiers?
  name_token: Ident?
  body: AnnotationBody?
}

ClassBody {
  members: ClassMember*
}

InterfaceBody {
  members: ClassMember*
}

EnumBody {
  constants: EnumConstant*
  members: ClassMember*
}

RecordBody {
  members: ClassMember*
}

AnnotationBody {
  members: ClassMember*
}

EnumConstant {
  name_token: Ident?
  arguments: ArgumentList?
}

FieldDeclaration {
  modifiers: Modifiers?
  type_parameters: TypeParameters?
  ty: Type?
  declarator_list: VariableDeclaratorList?
}

MethodDeclaration {
  modifiers: Modifiers?
  type_parameters: TypeParameters?
  name_token: Ident?
  parameter_list: ParameterList?
  default_value: DefaultValue?
  body: Block?
}

ConstructorDeclaration {
  modifiers: Modifiers?
  type_parameters: TypeParameters?
  name_token: Ident?
  parameter_list: ParameterList?
  body: Block?
}

InitializerBlock {
  modifiers: Modifiers?
  body: Block?
}

EmptyDeclaration {}

ParameterList {
  parameters: Parameter*
}

Parameter {
  modifiers: Modifiers?
  ty: Type?
  name_token: Ident?
}

Block {
  statements: Statement*
}

LabeledStatement {
  label_token: Ident?
  statement: Statement?
}

IfStatement {
  condition: Expression?
  then_branch: Statement?
  else_branch: Statement?
}

SwitchStatement {
  expression: Expression?
  block: SwitchBlock?
}

SwitchExpression {
  expression: Expression?
  block: SwitchBlock?
}

SwitchBlock {
  groups: SwitchGroup*
  rules: SwitchRule*
  statements: Statement*
}

SwitchGroup {
  labels: SwitchLabel*
  statements: Statement*
}

SwitchRule {
  labels: SwitchLabel*
  body: SwitchRuleBody?
}

SwitchLabel {
  case_kw: Token(CaseKw)?
  default_kw: Token(DefaultKw)?
  colon_token: Token(Colon)?
  arrow_token: Token(Arrow)?
  elements: CaseLabelElement*
}

CaseLabelElement {
  pattern: Pattern?
  expression: Expression?
  guard: Guard?
}

Guard {
  expression: Expression?
}

Pattern {
  type_pattern: TypePattern?
  record_pattern: RecordPattern?
}

TypePattern {
  modifiers: Modifiers?
  ty: Type?
  name_token: Ident?
  unnamed_pattern: UnnamedPattern?
}

RecordPattern {
  modifiers: Modifiers?
  ty: Type?
  components: Pattern*
}

UnnamedPattern {}

ForStatement {
  header: ForHeader?
  body: Statement?
}

ForHeader {}

WhileStatement {
  condition: Expression?
  body: Statement?
}

DoWhileStatement {
  body: Statement?
  condition: Expression?
}

SynchronizedStatement {
  expression: Expression?
  body: Block?
}

TryStatement {
  resources: ResourceSpecification?
  body: Block?
  catches: CatchClause*
  finally_clause: FinallyClause?
}

ResourceSpecification {
  resources: Resource*
}

Resource {}

CatchClause {
  body: Block?
}

FinallyClause {
  body: Block?
}

AssertStatement {
  condition: Expression?
  message: Expression?
}

YieldStatement {
  expression: Expression?
}

ReturnStatement {
  expression: Expression?
}

ThrowStatement {
  expression: Expression?
}

BreakStatement {
  label_token: Ident?
}

ContinueStatement {
  label_token: Ident?
}

LocalTypeDeclarationStatement {
  declaration: TypeDeclaration?
}

LocalVariableDeclarationStatement {
  modifiers: Modifiers?
  ty: Type?
  declarator_list: VariableDeclaratorList?
}

ExpressionStatement {
  expression: Expression?
}

EmptyStatement {}

VariableDeclaratorList {
  declarators: VariableDeclarator*
}

VariableDeclarator {
  name_token: Ident?
  unnamed_pattern: UnnamedPattern?
  initializer: Expression?
}

Type {
  primitive: PrimitiveType?
  named: NamedType?
}

PrimitiveType {}

NamedType {
  type_arguments: TypeArguments?
}

TypeArguments {
  arguments: TypeArgument*
}

TypeArgument {
  ty: Type?
  wildcard: WildcardType?
}

WildcardType {
  bound: Type?
}

ArgumentList {
  arguments: Expression*
}

LiteralExpression {}
NameExpression {}
ThisExpression {}
SuperExpression {}

ParenthesizedExpression {
  expression: Expression?
}

NewExpression {
  ty: Type?
  arguments: ArgumentList?
}

ArrayCreationExpression {
  ty: Type?
  dim_exprs: DimExprs?
  dims: Dims?
  initializer: ArrayInitializer?
}

DimExprs {
  dims: DimExpr*
}

DimExpr {
  expression: Expression?
}

Dims {
  dims: Dim*
}

Dim {}

MethodCallExpression {
  callee: Expression?
  arguments: ArgumentList?
}

FieldAccessExpression {
  expression: Expression?
  name_token: Ident?
}

ClassLiteralExpression {
  expression: Expression?
}

MethodReferenceExpression {
  expression: Expression?
  name_token: Ident?
}

ConstructorReferenceExpression {
  expression: Expression?
}

ArrayAccessExpression {
  array: Expression?
  index: Expression?
}

UnaryExpression {
  operand: Expression?
}

BinaryExpression {
  lhs: Expression?
  rhs: Expression?
}

InstanceofExpression {
  lhs: Expression?
  ty: Type?
  pattern: Pattern?
}

AssignmentExpression {
  lhs: Expression?
  rhs: Expression?
}

ConditionalExpression {
  condition: Expression?
  then_branch: Expression?
  else_branch: Expression?
}

LambdaExpression {
  body: LambdaBody?
}

CastExpression {
  ty: Type?
  expression: Expression?
}

ArrayInitializer {
  initializers: ArrayInitializerList?
}

ArrayInitializerList {
  initializers: VariableInitializer*
}

VariableInitializer {
  initializer: ArrayInitializer?
  expression: Expression?
}

ExtendsClause {
  types: Type*
}

ImplementsClause {
  types: Type*
}

PermitsClause {
  types: Type*
}

TypeParameters {
  type_parameters: TypeParameter*
}

TypeParameter {
  name_token: Ident?
  bounds: Type*
}

DefaultValue {
  value: AnnotationElementValue?
}

ExpressionRoot {
  expression: Expression?
}

Error {}

ModuleDeclaration {
  modifiers: Modifiers?
  open_kw: Token(OpenKw)?
  module_kw: Token(ModuleKw)
  name: Name?
  body: ModuleBody?
}

ModuleBody {
  directive_wrappers: ModuleDirective*
}

ModuleDirective {
  directive: ModuleDirectiveKind?
}

RequiresDirective {
  requires_kw: Token(RequiresKw)
  transitive_kw: Token(TransitiveKw)?
  static_kw: Token(StaticKw)?
  module: Name?
  semicolon: Token(Semicolon)?
}

ExportsDirective {
  exports_kw: Token(ExportsKw)
  package: Name?
  to_kw: Token(ToKw)?
  semicolon: Token(Semicolon)?
}

OpensDirective {
  opens_kw: Token(OpensKw)
  package: Name?
  to_kw: Token(ToKw)?
  semicolon: Token(Semicolon)?
}

UsesDirective {
  uses_kw: Token(UsesKw)
  service: Name?
  semicolon: Token(Semicolon)?
}

ProvidesDirective {
  provides_kw: Token(ProvidesKw)
  service: Name?
  with_kw: Token(WithKw)?
  semicolon: Token(Semicolon)?
}
